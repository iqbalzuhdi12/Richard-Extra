{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Komputasi Numerik \u00b6 Nama : Moh. Iqbal Zuhdi Husaeni NIM : 180411100051","title":"index"},{"location":"#komputasi-numerik","text":"Nama : Moh. Iqbal Zuhdi Husaeni NIM : 180411100051","title":"Komputasi Numerik"},{"location":"Tugas-1/","text":"Error in numerical computation \u00b6 Komputasi Numerik \u00b6 Komputasi numerik bisa dikatakan sebagai penentuan error suatu perhitungan untuk mencapai nilai akurasi. Komputer Numerik bertujuan untuk menentukan suatu akurasi dari hasil perhitungan atau percobaan. Komputer Numerik ini banyak sekali diimplementasikan dalam kehidupan termasuk dunia kedokteran, teknik, ekonomi, dan sains. Error \u00b6 Error merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Error disini dibagi menjadi 2 : 1. Absolute Error \u00b6 Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan $$ Ea = |X - x| $$ 2. Relative Error \u00b6 Relative error biasa disebut sebagai kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan Er. $$ Er = |Xt - Xa / Xt| $$ Deret Maclaurin \u00b6 Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Deret Taylor didefinisikan seperti berikut. $$ f(x) = f(a) + {f^1(a) (x-a) \\over 1!} + {f^2(a) (x-a)^2 \\over 2!} + {f^3(a) (x-a)^3 \\over 3!} ... {f^n(a) (x-a)^n \\over n!} $$ Deret MacLaurin hampir sama dengan dengan Deret Taylor, hanya saja dalam deret maclaurin nilai a=0, sehingga persamaannya adalah seperti berikut. $$ f(x) = f(0) + {f^1(0)x \\over 1!} + {f^2(0)x^2 \\over 2!} + {f^3(0)x^3 \\over 3!} ... {f^n(0)x^n \\over n!} $$ Deret MacLaurin biasa disebut sebagai deret Taylor baku, kerena deret maclaurin merupakan standar atau dasar yang berlaku dengan a=0. Atau persamaan Deret MacLaurin diatas dapat ditulis seperti berikut. $$ f(x) = \\sum \\limits_{i=0}^{n} {f^i(0)x^i \\over i!} $$ Implementasi Program \u00b6 membuat program supaya dapaat mengekspansi bilangan e^3x dengan nilai x=1 hingga nilai menjadi kurang dari 0,001 bisa dengan Implementasi Program sebagai berikut. #f(x)=e**3x import math x = 1 i = 1 f = 1 while i > 0 : e = (( 3 ** i ) * x ** i ) / math . factorial ( i ) f1 = f + e print ( \"iterasi ke-\" + str ( i )) print ( \"Hasil suku lama =\" , f ) print ( \"Hasil suku baru =\" , f1 ) h = abs ( f - f1 ) #ini selisih print ( \"selisih =\" , h , \" \\n \" ) if h <= 0.001 : break else : f += e i += 1 print ( \"jumlah iterasi =\" , i ) Output : iterasi ke-1 Hasil suku lama = 1 Hasil suku baru = 4.0 selisih = 3.0 iterasi ke-2 Hasil suku lama = 4.0 Hasil suku baru = 8.5 selisih = 4.5 iterasi ke-3 Hasil suku lama = 8.5 Hasil suku baru = 13.0 selisih = 4.5 iterasi ke-4 Hasil suku lama = 13.0 Hasil suku baru = 16.375 selisih = 3.375 iterasi ke-5 Hasil suku lama = 16.375 Hasil suku baru = 18.4 selisih = 2.0249999999999986 iterasi ke-6 Hasil suku lama = 18.4 Hasil suku baru = 19.412499999999998 selisih = 1.0124999999999993 iterasi ke-7 Hasil suku lama = 19.412499999999998 Hasil suku baru = 19.846428571428568 selisih = 0.4339285714285701 iterasi ke-8 Hasil suku lama = 19.846428571428568 Hasil suku baru = 20.009151785714284 selisih = 0.162723214285716 iterasi ke-9 Hasil suku lama = 20.009151785714284 Hasil suku baru = 20.063392857142855 selisih = 0.05424107142857082 iterasi ke-10 Hasil suku lama = 20.063392857142855 Hasil suku baru = 20.079665178571425 selisih = 0.016272321428569825 iterasi ke-11 Hasil suku lama = 20.079665178571425 Hasil suku baru = 20.08410308441558 selisih = 0.004437905844156376 iterasi ke-12 Hasil suku lama = 20.08410308441558 Hasil suku baru = 20.08521256087662 selisih = 0.001109476461039094 iterasi ke-13 Hasil suku lama = 20.08521256087662 Hasil suku baru = 20.08546859390609 selisih = 0.0002560330294691937 jumlah iterasi = 13 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Error in Numerical"},{"location":"Tugas-1/#error-in-numerical-computation","text":"","title":"Error in numerical computation"},{"location":"Tugas-1/#komputasi-numerik","text":"Komputasi numerik bisa dikatakan sebagai penentuan error suatu perhitungan untuk mencapai nilai akurasi. Komputer Numerik bertujuan untuk menentukan suatu akurasi dari hasil perhitungan atau percobaan. Komputer Numerik ini banyak sekali diimplementasikan dalam kehidupan termasuk dunia kedokteran, teknik, ekonomi, dan sains.","title":"Komputasi Numerik"},{"location":"Tugas-1/#error","text":"Error merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Error disini dibagi menjadi 2 :","title":"Error"},{"location":"Tugas-1/#1-absolute-error","text":"Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan $$ Ea = |X - x| $$","title":"1. Absolute Error"},{"location":"Tugas-1/#2-relative-error","text":"Relative error biasa disebut sebagai kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan Er. $$ Er = |Xt - Xa / Xt| $$","title":"2. Relative Error"},{"location":"Tugas-1/#deret-maclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Deret Taylor didefinisikan seperti berikut. $$ f(x) = f(a) + {f^1(a) (x-a) \\over 1!} + {f^2(a) (x-a)^2 \\over 2!} + {f^3(a) (x-a)^3 \\over 3!} ... {f^n(a) (x-a)^n \\over n!} $$ Deret MacLaurin hampir sama dengan dengan Deret Taylor, hanya saja dalam deret maclaurin nilai a=0, sehingga persamaannya adalah seperti berikut. $$ f(x) = f(0) + {f^1(0)x \\over 1!} + {f^2(0)x^2 \\over 2!} + {f^3(0)x^3 \\over 3!} ... {f^n(0)x^n \\over n!} $$ Deret MacLaurin biasa disebut sebagai deret Taylor baku, kerena deret maclaurin merupakan standar atau dasar yang berlaku dengan a=0. Atau persamaan Deret MacLaurin diatas dapat ditulis seperti berikut. $$ f(x) = \\sum \\limits_{i=0}^{n} {f^i(0)x^i \\over i!} $$","title":"Deret Maclaurin"},{"location":"Tugas-1/#implementasi-program","text":"membuat program supaya dapaat mengekspansi bilangan e^3x dengan nilai x=1 hingga nilai menjadi kurang dari 0,001 bisa dengan Implementasi Program sebagai berikut. #f(x)=e**3x import math x = 1 i = 1 f = 1 while i > 0 : e = (( 3 ** i ) * x ** i ) / math . factorial ( i ) f1 = f + e print ( \"iterasi ke-\" + str ( i )) print ( \"Hasil suku lama =\" , f ) print ( \"Hasil suku baru =\" , f1 ) h = abs ( f - f1 ) #ini selisih print ( \"selisih =\" , h , \" \\n \" ) if h <= 0.001 : break else : f += e i += 1 print ( \"jumlah iterasi =\" , i ) Output : iterasi ke-1 Hasil suku lama = 1 Hasil suku baru = 4.0 selisih = 3.0 iterasi ke-2 Hasil suku lama = 4.0 Hasil suku baru = 8.5 selisih = 4.5 iterasi ke-3 Hasil suku lama = 8.5 Hasil suku baru = 13.0 selisih = 4.5 iterasi ke-4 Hasil suku lama = 13.0 Hasil suku baru = 16.375 selisih = 3.375 iterasi ke-5 Hasil suku lama = 16.375 Hasil suku baru = 18.4 selisih = 2.0249999999999986 iterasi ke-6 Hasil suku lama = 18.4 Hasil suku baru = 19.412499999999998 selisih = 1.0124999999999993 iterasi ke-7 Hasil suku lama = 19.412499999999998 Hasil suku baru = 19.846428571428568 selisih = 0.4339285714285701 iterasi ke-8 Hasil suku lama = 19.846428571428568 Hasil suku baru = 20.009151785714284 selisih = 0.162723214285716 iterasi ke-9 Hasil suku lama = 20.009151785714284 Hasil suku baru = 20.063392857142855 selisih = 0.05424107142857082 iterasi ke-10 Hasil suku lama = 20.063392857142855 Hasil suku baru = 20.079665178571425 selisih = 0.016272321428569825 iterasi ke-11 Hasil suku lama = 20.079665178571425 Hasil suku baru = 20.08410308441558 selisih = 0.004437905844156376 iterasi ke-12 Hasil suku lama = 20.08410308441558 Hasil suku baru = 20.08521256087662 selisih = 0.001109476461039094 iterasi ke-13 Hasil suku lama = 20.08521256087662 Hasil suku baru = 20.08546859390609 selisih = 0.0002560330294691937 jumlah iterasi = 13 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Implementasi Program"},{"location":"Tugas-2/","text":"Numerical Solution of Algebraic and Transcendental Equation \u00b6 Metode Bisection \u00b6 Metode Bisection ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma metode bisection Definisikan fungsi f(x) yang akan dicari akarnya tentukan range atau nilai a dan b tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Code Program #Bisection def bis ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : x = ( a + b ) / 2 fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x elif fx * fb < 0 : a = x if abs ( a - b ) < e : print ( \"Jumlah Iterasi : \" , n ) print ( x ) else : n += 1 print ( \"iterasi ke-\" + str ( n )) bis ( a , b , n ) else : if fa < fb : a -= 0.1 elif fb < fa : b += 0.1 bis ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) bis ( a , b , 0 ) Output Masukkan nilai a : 1 Masukkan nilai b : 2.3 iterasi ke - 1 iterasi ke - 2 iterasi ke - 3 iterasi ke - 4 iterasi ke - 5 iterasi ke - 6 iterasi ke - 7 iterasi ke - 8 iterasi ke - 9 iterasi ke - 10 Jumlah Iterasi : 10 1.9997558593749996 Metode Regula Falsi \u00b6 Metode regula falsi adalah Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Rumus c dari regula falsi : $$ c = a-f(a) \\frac{(b-a)}{f(b)-f(a)} $$ Algoritma metode regula falsi (benerin lagii) Definisikan fungsi f(x) yang akan dicari akarnya tentukan batas atas dan batas bawah tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Code Program #Regula-Falsi def Regfal ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : n += 1 print ( \"iterasi ke-\" + str ( n )) x = (( a * abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x else : a = x if abs ( a - b ) < e : print ( x ) else : Regfal ( a , b , n ) else : if fa < fb : a -= 0.1 else : b += 0.1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a : \" )) b = float ( input ( \"Masukkan interval b : \" )) Regfal ( a , b , 0 ) Output Masukkan interval a : 1 Masukkan interval b : 2.1 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 iterasi ke-33 iterasi ke-34 iterasi ke-35 iterasi ke-36 iterasi ke-37 iterasi ke-38 iterasi ke-39 iterasi ke-40 iterasi ke-41 iterasi ke-42 iterasi ke-43 iterasi ke-44 iterasi ke-45 iterasi ke-46 iterasi ke-47 2.0000000000000004 Metode Newton Raphson \u00b6 \u200b Dalam analisis numerik, metode Newton / Newton-Raphson yang mendapat nama dari Isaac Newton dan Joseph Rapshon, merupakan metode yang paling dikenal untuk mencari akar suatu fungsi f(x) dengan pendekatan satu titik dimana fungsi f(x) mempunyai turunan. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus yang menyinggung titik f(x_0) . Hal ini berakibat garis I memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. persamaan garis I : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 perpotongan garis I dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 maka koordinat titik ( x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ f'(x_n)=\\frac{f(x_n)-0}{f'(x_n)-{x_{n+1}}} $$ atau dapat diatur kembali menjadi : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_{n+1} = x_{n} - \\frac{f(x_{n})}{f'(x_{n})} $$ Program #Newton-Raphson x = float ( input ( \"Masukkan nilai awal x : \" )) n = 0 e = 0.001 while n >= 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 fax = 2 * x - 5 x1 = x - ( fx / fax ) if abs ( x1 - x ) < e or n >= 100 : print ( \"Jumlah iterasi : \" , n + 1 ) print ( x ) break else : x = x1 n += 1 Output Masukkan nilai awal x : 2.4 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 iterasi saat X5 Jumlah iterasi : 6 1.9999976821746035 Metode Secant \u00b6 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen.Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus Metode Secant $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ Algoritma Metode Secant Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x0 dan x1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x0 ) dan f(x1) Untuk iterasi 1 s/d N : $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ $$ Hitungf(x_{r+1}) $$ Program #Secant def Secant ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 * x + 6 n += 1 print ( \"iterasi ke-\" + str ( n )) if abs ( a - b ) < e : print ( \"Jumlah iterasi :\" , n ) print ( x ) else : a = b b = x Secant ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) n = 0 Secant ( a , b , 0 ) Output Masukkan nilai a : 1 Masukkan nilai b : 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi : 6 1.9999999975499005 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Numerical Solution"},{"location":"Tugas-2/#numerical-solution-of-algebraic-and-transcendental-equation","text":"","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"Tugas-2/#metode-bisection","text":"Metode Bisection ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma metode bisection Definisikan fungsi f(x) yang akan dicari akarnya tentukan range atau nilai a dan b tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Code Program #Bisection def bis ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : x = ( a + b ) / 2 fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x elif fx * fb < 0 : a = x if abs ( a - b ) < e : print ( \"Jumlah Iterasi : \" , n ) print ( x ) else : n += 1 print ( \"iterasi ke-\" + str ( n )) bis ( a , b , n ) else : if fa < fb : a -= 0.1 elif fb < fa : b += 0.1 bis ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) bis ( a , b , 0 ) Output Masukkan nilai a : 1 Masukkan nilai b : 2.3 iterasi ke - 1 iterasi ke - 2 iterasi ke - 3 iterasi ke - 4 iterasi ke - 5 iterasi ke - 6 iterasi ke - 7 iterasi ke - 8 iterasi ke - 9 iterasi ke - 10 Jumlah Iterasi : 10 1.9997558593749996","title":"Metode Bisection"},{"location":"Tugas-2/#metode-regula-falsi","text":"Metode regula falsi adalah Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Rumus c dari regula falsi : $$ c = a-f(a) \\frac{(b-a)}{f(b)-f(a)} $$ Algoritma metode regula falsi (benerin lagii) Definisikan fungsi f(x) yang akan dicari akarnya tentukan batas atas dan batas bawah tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Code Program #Regula-Falsi def Regfal ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : n += 1 print ( \"iterasi ke-\" + str ( n )) x = (( a * abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x else : a = x if abs ( a - b ) < e : print ( x ) else : Regfal ( a , b , n ) else : if fa < fb : a -= 0.1 else : b += 0.1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a : \" )) b = float ( input ( \"Masukkan interval b : \" )) Regfal ( a , b , 0 ) Output Masukkan interval a : 1 Masukkan interval b : 2.1 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 iterasi ke-33 iterasi ke-34 iterasi ke-35 iterasi ke-36 iterasi ke-37 iterasi ke-38 iterasi ke-39 iterasi ke-40 iterasi ke-41 iterasi ke-42 iterasi ke-43 iterasi ke-44 iterasi ke-45 iterasi ke-46 iterasi ke-47 2.0000000000000004","title":"Metode Regula Falsi"},{"location":"Tugas-2/#metode-newton-raphson","text":"\u200b Dalam analisis numerik, metode Newton / Newton-Raphson yang mendapat nama dari Isaac Newton dan Joseph Rapshon, merupakan metode yang paling dikenal untuk mencari akar suatu fungsi f(x) dengan pendekatan satu titik dimana fungsi f(x) mempunyai turunan. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus yang menyinggung titik f(x_0) . Hal ini berakibat garis I memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. persamaan garis I : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 perpotongan garis I dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 maka koordinat titik ( x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ f'(x_n)=\\frac{f(x_n)-0}{f'(x_n)-{x_{n+1}}} $$ atau dapat diatur kembali menjadi : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_{n+1} = x_{n} - \\frac{f(x_{n})}{f'(x_{n})} $$ Program #Newton-Raphson x = float ( input ( \"Masukkan nilai awal x : \" )) n = 0 e = 0.001 while n >= 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 fax = 2 * x - 5 x1 = x - ( fx / fax ) if abs ( x1 - x ) < e or n >= 100 : print ( \"Jumlah iterasi : \" , n + 1 ) print ( x ) break else : x = x1 n += 1 Output Masukkan nilai awal x : 2.4 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 iterasi saat X5 Jumlah iterasi : 6 1.9999976821746035","title":"Metode Newton Raphson"},{"location":"Tugas-2/#metode-secant","text":"Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen.Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus Metode Secant $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ Algoritma Metode Secant Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x0 dan x1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x0 ) dan f(x1) Untuk iterasi 1 s/d N : $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ $$ Hitungf(x_{r+1}) $$ Program #Secant def Secant ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 * x + 6 n += 1 print ( \"iterasi ke-\" + str ( n )) if abs ( a - b ) < e : print ( \"Jumlah iterasi :\" , n ) print ( x ) else : a = b b = x Secant ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) n = 0 Secant ( a , b , 0 ) Output Masukkan nilai a : 1 Masukkan nilai b : 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi : 6 1.9999999975499005 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Secant"},{"location":"Tugas-3/","text":"Penyelesaian Sistem Persamaan Linier Menggunakan Metode Gauss Jordan, Gauss Jacobi, Gauss Seidel \u00b6 Eliminasi Gauss Jordan \u00b6 Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Persamaan Linier"},{"location":"Tugas-3/#penyelesaian-sistem-persamaan-linier-menggunakan-metode-gauss-jordan-gauss-jacobi-gauss-seidel","text":"","title":"Penyelesaian Sistem Persamaan Linier Menggunakan Metode Gauss Jordan, Gauss Jacobi, Gauss Seidel"},{"location":"Tugas-3/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan"},{"location":"Tugas-3/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan"},{"location":"Tugas-3/#_1","text":"","title":""},{"location":"Tugas-3/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program"},{"location":"Tugas-3/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi"},{"location":"Tugas-3/#listing-program_1","text":"from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"Tugas-3/#program-gauss-seidel","text":"","title":"Program Gauss Seidel"},{"location":"Tugas-3/#listing-program_2","text":"def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program"},{"location":"Tugas-4/","text":"INTEGRASI NUMERIK \u00b6 METODE INTEGRASI ROMBERG \u00b6 A. Pengertian \u00b6 Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses integrasi Romberg, mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: \u200b I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) \u200b I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) \u200b I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai B. Code Program \u00b6 import numpy as np def trapezcomp ( f , a , b , n ): h = ( b - a ) / n x = a In = f ( a ) for k in range ( 1 , n ): x = x + h In += 2 * f ( x ) return ( In + f ( b )) * h * 0.5 def romberg ( f , a , b , p ): I = np . zeros (( p , p )) for k in range ( 0 , p ): I [ k , 0 ] = trapezcomp ( f , a , b , 2 ** k ) for j in range ( 0 , k ): I [ k , j + 1 ] = ( 4 ** ( j + 1 ) * I [ k , j ] - I [ k - 1 , j ]) / ( 4 ** ( j + 1 ) - 1 ) print ( I [ k , 0 : k + 1 ]) return I if __name__ == '__main__' : def func ( x ): return np . sin ( x ) p_rows = 4 I = romberg ( func , 0 , np . pi / 2 , p_rows ) solution = I [ p_rows - 1 , p_rows - 1 ] print ( solution ) # 1.00000000814 C. Output \u00b6 [ 0.78539816 ] [ 0.94805945 1.00227988 ] [ 0.9871158 1.00013458 0.99999157 ] [ 0.99678517 1.0000083 0.99999988 1.00000001 ] 1.0000000081440203","title":"Integrasi Numerik"},{"location":"Tugas-4/#integrasi-numerik","text":"","title":"INTEGRASI NUMERIK"},{"location":"Tugas-4/#metode-integrasi-romberg","text":"","title":"METODE INTEGRASI ROMBERG"},{"location":"Tugas-4/#a-pengertian","text":"Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses integrasi Romberg, mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: \u200b I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) \u200b I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) \u200b I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai","title":"A. Pengertian"},{"location":"Tugas-4/#b-code-program","text":"import numpy as np def trapezcomp ( f , a , b , n ): h = ( b - a ) / n x = a In = f ( a ) for k in range ( 1 , n ): x = x + h In += 2 * f ( x ) return ( In + f ( b )) * h * 0.5 def romberg ( f , a , b , p ): I = np . zeros (( p , p )) for k in range ( 0 , p ): I [ k , 0 ] = trapezcomp ( f , a , b , 2 ** k ) for j in range ( 0 , k ): I [ k , j + 1 ] = ( 4 ** ( j + 1 ) * I [ k , j ] - I [ k - 1 , j ]) / ( 4 ** ( j + 1 ) - 1 ) print ( I [ k , 0 : k + 1 ]) return I if __name__ == '__main__' : def func ( x ): return np . sin ( x ) p_rows = 4 I = romberg ( func , 0 , np . pi / 2 , p_rows ) solution = I [ p_rows - 1 , p_rows - 1 ] print ( solution ) # 1.00000000814","title":"B. Code Program"},{"location":"Tugas-4/#c-output","text":"[ 0.78539816 ] [ 0.94805945 1.00227988 ] [ 0.9871158 1.00013458 0.99999157 ] [ 0.99678517 1.0000083 0.99999988 1.00000001 ] 1.0000000081440203","title":"C. Output"},{"location":"Tugas-5/","text":"Richardson Extrapolation \u00b6 Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Teori \u00b6 Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc. Contoh Program \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): '''Richardson extrapolation method for numerical calculation of first derivative ''' k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<' ) print ( \"=======================================================================\" ) print ( 'f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( \"=======================================================================\" ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( \"=======================================================================\" ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) Hasil Running \u00b6 >>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<< ======================================================================= f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 ======================================================================= - 0.91250000000000530687 ======================================================================= diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050 >>>","title":"Richardson Extrapolation"},{"location":"Tugas-5/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa.","title":"Richardson Extrapolation"},{"location":"Tugas-5/#teori","text":"Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc.","title":"Teori"},{"location":"Tugas-5/#contoh-program","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): '''Richardson extrapolation method for numerical calculation of first derivative ''' k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<' ) print ( \"=======================================================================\" ) print ( 'f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( \"=======================================================================\" ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( \"=======================================================================\" ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 ))","title":"Contoh Program"},{"location":"Tugas-5/#hasil-running","text":">>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<< ======================================================================= f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 ======================================================================= - 0.91250000000000530687 ======================================================================= diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050 >>>","title":"Hasil Running"}]}